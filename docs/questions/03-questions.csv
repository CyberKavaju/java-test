domain,topic,question_text,option_a,option_b,option_c,option_d,option_e,correct_answer,explanation
Java Basics,Class Structure,What is the minimum requirement for a Java source file to compile and run successfully?,It must contain a public class with a main method.,It must contain a class with a main method.,It must contain a public static void main(String[] args) method.,It must contain at least one class definition.,It must have a package declaration.,B,"A Java source file only needs to contain a class with a main method to compile and run. The class does not necessarily have to be public, nor does it need a package declaration if it's in the default package. While the main method signature public static void main(String[] args) is specific, the question asks for the minimum requirement for the file itself. A file with a non-public class containing a main method can be compiled and run."
Java Basics,Main Method,Given the code: public class Test { public static long main(String[] args) { System.out.println(""Hello""); return 10L; } } What will be the outcome when this code is executed?,Hello,It will not print anything.,It will not compile.,It will throw an Error at runtime.,None of the above.,D,"The Java Virtual Machine (JVM) specifically looks for a main() method with the signature public static void main(String[] args). The main() method in the given code has a return type of long instead of void. Because the JVM cannot find the expected main method signature, it will throw a NoSuchMethodError at runtime."
Working With Java Data Types,Variable Initialization,What is the default value for an uninitialized instance variable of type double?,0,0.0,null,undefined,It depends on the JVM.,B,"Instance variables (fields) in Java are automatically initialized to their default values if not explicitly assigned. For numeric primitive types like double, the default value is 0.0. For int it's 0, for boolean it's false, and for object references it's null."
Working With Java Data Types,Wrapper Classes,Which of the following statements will print true when executed?,System.out.println(Boolean.parseBoolean(""true""));,System.out.println(new Boolean(null));,System.out.println(new Boolean());,System.out.println(new Boolean(""True""));,System.out.println(new Boolean(""FALSE""));,A,"Boolean.parseBoolean(String) returns a primitive boolean. It returns true if the string is ""true"" (ignoring case). new Boolean(null) creates a Boolean object representing false. new Boolean() causes a compile-time error as there is no no-argument constructor for Boolean. new Boolean(""True"") creates a Boolean object representing true, so this would also print true. new Boolean(""FALSE"") creates a Boolean object representing false. Since the question asks for statements that will print true, option A is the correct choice."
Working With Java Data Types,Object Lifecycle,How many objects are created by the time the main method finishes in the following code? public class Creator { public Creator() { try { throw new Exception(); } catch (Exception e) {} } public static void main(String[] args) { Creator c1 = new Creator(); Creator c2 = new Creator(); Creator c3 = c1; } },2,3,4,5,6,C,"Let's trace object creation: 1. Creator c1 = new Creator(); creates one Creator object. Inside its constructor, new Exception() creates one Exception object. (Total: 2 objects). 2. Creator c2 = new Creator(); creates another Creator object. Inside its constructor, another Exception object is created. (Total: 2 more objects). 3. Creator c3 = c1; only creates a new reference c3 and points it to the existing c1 object. No new object is created. Total objects created: 2 + 2 = 4."
Using Operators and Decision Constructs,Operator Precedence,What is the final value of result? int x = 5; int y = 10; int z = 15; boolean result = x < y && y < z || z > x;,true,false,Compilation error,Runtime error,Depends on JVM,A,"The expression x < y && y < z || z > x evaluates as follows: 1. x < y (5 < 10) is true. 2. y < z (10 < 15) is true. 3. z > x (15 > 5) is true. 4. true && true (due to && having higher precedence than ||) evaluates to true. 5. true || true evaluates to true. So, result is true."
Using Operators and Decision Constructs,Ternary Operator,What will be printed by the following code? int a = 10; int b = 20; String s = (a > b)? ""A is greater"" : (a < b)? ""B is greater"" : ""A and B are equal""; System.out.println(s);,A is greater,B is greater,A and B are equal,Compilation error,Runtime error,B,"The ternary operator condition? value_if_true : value_if_false is evaluated. First, (a > b) which is (10 > 20) is false. So, it evaluates the second part: (a < b)? ""B is greater"" : ""A and B are equal"". Here, (a < b) which is (10 < 20) is true. So, it returns ""B is greater"". The output is ""B is greater""."
Using Operators and Decision Constructs,Switch Statement,What is the output of the following code? public class Test { public static void main(String[] args) { int day = 2; switch (day) { case 1: System.out.print(""Monday""); case 2: System.out.print(""Tuesday""); case 3: System.out.print(""Wednesday""); default: System.out.print(""Invalid""); } } },Tuesday,TuesdayWednesday,TuesdayWednesdayInvalid,Compilation error,Runtime error,C,"The switch statement starts execution at the matching case label. Since day is 2, it starts at case 2, printing ""Tuesday"". Because there is no break statement after case 2, execution ""falls through"" to case 3, printing ""Wednesday"". It then falls through to default, printing ""Invalid"". The combined output is ""TuesdayWednesdayInvalid""."
Using Operators and Decision Constructs,Equality Operators,What will the following code print? String s1 = ""Java""; String s2 = new String(""Java""); System.out.println(s1 == s2); System.out.println(s1.equals(s2));,true true,false false,true false,false true,Compilation error,D,"The == operator compares object references. s1 refers to a String literal ""Java"" in the String pool, while s2 refers to a new String object created on the heap. They are different objects, so s1 == s2 is false. The equals() method for String objects compares their content. Since both s1 and s2 contain the same sequence of characters ""Java"", s1.equals(s2) is true. Thus, the output is false followed by true."
Creating and Using Arrays,Array Declaration,Which of the following array declarations are valid?,int[] numbers = new int[5];,int[] numbers = new int[5];,int[] numbers = {1, 2, 3};,int[] numbers; numbers = new int[5];,All of the above.,E,"All listed options are valid ways to declare and/or initialize arrays in Java. Options A and B show two common syntaxes for declaring array variables (int[] numbers or int numbers[]). Option C shows array initialization with an initializer list. Option D shows declaration and instantiation in separate steps. All are syntactically correct."
Creating and Using Arrays,Multi-dimensional Arrays,What is the output of the following code? int[][] matrix = new int[2][]; matrix[0] = new int[]{1, 2}; matrix[1] = new int[]{3, 4, 5}; System.out.println(matrix[0].length + matrix[1].length);,5,6,7,Compilation error,Runtime error,A,"The code declares a jagged array (a 2D array where inner arrays can have different lengths). matrix[0] is initialized with length 2. matrix[1] is initialized with length 3. The System.out.println statement adds the lengths of these two inner arrays: 2 + 3 = 5. The output is 5."
Using Loop Constructs,For Loop,What is the output of the following code? for (int i = 0; i < 5; i++) { if (i == 2) continue; System.out.print(i); },01234,0134,0123,1234,Compilation error,B,"The for loop iterates from i = 0 to 4. When i is 0, it prints 0. When i is 1, it prints 1. When i is 2, the if (i == 2) condition is true, and continue is executed. continue skips the rest of the current iteration and proceeds to the next iteration of the loop. So, 2 is not printed. When i is 3, it prints 3. When i is 4, it prints 4. The output is 0134."
Using Loop Constructs,Do-While Loop,What is the output of the following code? int count = 5; do { System.out.print(count-- + "" ""); } while (count >= 0);,5 4 3 2 1 0 ,5 4 3 2 1 ,4 3 2 1 0 ,-1 0 1 2 3 4 5 ,Compilation error,A,"The do-while loop executes its body at least once before checking the condition. In the first iteration, count is 5, 5 is printed, and count becomes 4. The condition 4 >= 0 is true. This continues until count becomes 0. In the last iteration, count is 0, 0 is printed, and count becomes -1. The condition -1 >= 0 is now false, and the loop terminates. The output is 5 4 3 2 1 0 ."
Using Loop Constructs,Break and Continue,Given the code: String[] arr = {""A"", ""B"", ""C"", ""D""}; for (String s : arr) { if (s.equals(""B"")) continue; if (s.equals(""D"")) break; System.out.print(s); },AC,ABC,ABCD,A,Compilation error,A,"The enhanced for loop iterates through the array. 1. s = ""A"": s.equals(""B"") is false. s.equals(""D"") is false. Prints ""A"". 2. s = ""B"": s.equals(""B"") is true. continue is executed, skipping the print statement and moving to the next iteration. 3. s = ""C"": s.equals(""B"") is false. s.equals(""D"") is false. Prints ""C"". 4. s = ""D"": s.equals(""B"") is false. s.equals(""D"") is true. break is executed, terminating the loop entirely. The output is ""AC""."
Working with Methods and Encapsulation,Method Overloading,Which add method will be called? public class Calculator { public void add(int a, int b) { System.out.println(""int sum""); } public void add(double a, double b) { System.out.println(""double sum""); } public void add(long a, long b) { System.out.println(""long sum""); } public static void main(String[] args) { Calculator calc = new Calculator(); calc.add(10, 20); } },int sum,double sum,long sum,Compilation error,Runtime error,A,"When calc.add(10, 20) is called, both arguments 10 and 20 are int literals. The most specific matching method is add(int a, int b). No widening or autoboxing is needed for this signature, so it is chosen over add(long, long) or add(double, double)."
Working with Methods and Encapsulation,Static Keyword,What is the output of the following code? public class Counter { static int count = 0; public Counter() { count++; } public static void main(String[] args) { Counter c1 = new Counter(); Counter c2 = new Counter(); System.out.println(Counter.count); } },0,1,2,Compilation error,Runtime error,C,"The count variable is static, meaning it belongs to the class, not to individual objects. There is only one copy of count shared by all instances of Counter. Each time a Counter object is created (i.e., the constructor is called), count is incremented. So, c1 increments count to 1, and c2 increments count to 2. Printing Counter.count will output 2."
Working with Methods and Encapsulation,Constructors,Given the classes: class A { public A(int x) {} } class B extends A { public B(int x, int y) { super(x); } } Which of these constructors can be added to class B without causing a compile-time error?,B() {},B(int y) { j = y; },B(int y) { super(y*2); j = y; },B(int y) { i = y; j = y*2; },B(int z) { this(z, z); },C,"When a subclass constructor is invoked, its superclass constructor must be called first, either explicitly using super() or super(args), or implicitly using super() if the superclass has a no-argument constructor. Class A only has A(int x), so super() is not implicitly available. Options A, B, and D do not explicitly call a superclass constructor, and A lacks a no-args constructor, leading to compilation errors. Option C, B(int y) { super(y*2); j = y; }, explicitly calls super(int), which is valid. Option E, B(int z) { this(z, z); }, is also valid because it calls another constructor within the same class (B(int x, int y)), which in turn correctly calls super(x). Since only one option can be selected, C is a valid choice."
Working with Methods and Encapsulation,Access Modifiers,Which access modifier allows a member to be accessed only within its own class?,public,protected,private,default,static,C,"The private access modifier restricts access to members (fields or methods) to only within the class where they are declared. public allows access from anywhere. protected allows access within the same package and by subclasses. default (no modifier) allows access only within the same package."
Working with Methods and Encapsulation,Encapsulation,The Triangle class needs to protect an invariant on the ""area"" field (area = base * height / 2). Which member must have the public access modifier removed to ensure the invariant is maintained? public class Triangle { public int base; public int height; public double area; public Triangle(int base, int height) { this.base = base; this.height = height; updateArea(); } void updateArea() { area = base * height / 2; } public void setBase(int b) { base = b; updateArea(); } public void setHeight(int h) { height = h; updateArea(); } },the base field,the height field,the area field,the Triangle constructor,the setBase method,C,"To protect the invariant that area is always base * height / 2, direct external modification of area must be prevented. If the area field is public, external code can change it without triggering updateArea(), thus breaking the invariant. Making it private (removing public) ensures that changes can only occur through controlled methods like setBase and setHeight, which correctly call updateArea(). The constructor already calls updateArea(), and the setter methods are necessary for controlled modification."
Working with Inheritance,Polymorphism,What is the output of the following code? class Animal { public void makeSound() { System.out.println(""Animal sound""); } } class Dog extends Animal { public void makeSound() { System.out.println(""Woof""); } } public class Test { public static void main(String[] args) { Animal myDog = new Dog(); myDog.makeSound(); } },Animal sound,Woof,Compilation error,Runtime error,None of the above.,B,"This demonstrates polymorphism. Although myDog is declared as an Animal reference, it points to a Dog object. When an overridden method (makeSound()) is called, the method of the actual object (the runtime type), which is Dog, is invoked. Therefore, ""Woof"" is printed."
Working with Inheritance,Method Overriding vs. Field Hiding,What will the following code print when compiled and run? class Parent { public int value = 10; public void printValue() { System.out.println(""Parent: "" + value); } } class Child extends Parent { public int value = 20; public void printValue() { System.out.println(""Child: "" + value); } } public class Test { public static void main(String[] args) { Parent p = new Child(); System.out.println(p.value); p.printValue(); } },10,20,Parent: 10,Child: 20,10 Child: 20,E,"This question tests the difference between method overriding (polymorphism) and field hiding. When an instance variable is accessed, the variable accessed depends on the reference type (compile-time type), not the object type. So, p.value accesses Parent's value, which is 10. However, when an instance method is called, the method invoked depends on the object type (runtime type). Since p refers to a Child object, p.printValue() calls Child's printValue() method. Inside Child.printValue(), value refers to Child's value, which is 20. So, the output will be 10 followed by Child: 20."
Working with Inheritance,Abstract Classes and Interfaces,Which statement about abstract classes and interfaces is true?,A class can implement multiple abstract classes.,An interface can have concrete methods before Java 8.,An abstract class can have constructors.,All methods in an interface must be abstract.,An abstract class cannot have any concrete methods.,C,"An abstract class can have constructors, though they cannot be directly instantiated. They are used to initialize the state of the abstract class's fields when a concrete subclass is instantiated. A class can implement multiple interfaces, but only extend one class (abstract or concrete). Interfaces could not have concrete methods before Java 8 (only static and default methods were allowed from Java 8 onwards). Not all methods in an interface must be abstract (default and static methods are allowed in Java 8+). An abstract class can have both abstract and concrete methods."
Handling Exceptions,Checked vs Unchecked,Which of the following is an unchecked exception?,IOException,SQLException,FileNotFoundException,NullPointerException,InterruptedException,D,"Unchecked exceptions are subclasses of RuntimeException or Error. They do not need to be declared or caught. NullPointerException is a RuntimeException and thus an unchecked exception. IOException, SQLException, FileNotFoundException, and InterruptedException are all checked exceptions, meaning they must be handled or declared in the method signature."
Handling Exceptions,Try-Catch Block,What is the output of the following code? public class ExceptionTest { public static void main(String[] args) { try { int[] numbers = new int[5]; System.out.println(numbers[5]); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(""Array Index Error""); } catch (Exception e) { System.out.println(""General Error""); } finally { System.out.println(""Finally Block""); } } },Array Index Error,General Error,Array Index Error Finally Block,General Error Finally Block,Compilation error,C,"The code attempts to access numbers[5], which is outside the bounds of the array (indices 0-4). This throws an ArrayIndexOutOfBoundsException. The first catch block specifically handles this exception, so ""Array Index Error"" is printed. The finally block always executes, regardless of whether an exception occurred or was caught. So, ""Finally Block"" is printed next. The output is ""Array Index Error Finally Block""."
Handling Exceptions,Method Throwing Exception,Consider the code: class A { public void doA() throws Exception { throw new Exception(); } } class B extends A { public void doB() { doA(); } } public class Test { public static void main(String[] args) { B b = new B(); b.doB(); } } Which statement is correct?,The code compiles and runs without error.,The code compiles if throws Exception is added to doB().,The code compiles if throws Exception is added to main().,The code compiles if throws Exception is added to doB() AND main().,The code compiles if doA() is enclosed in a try-catch block within doB().,D,"doA() declares that it throws Exception (a checked exception). Therefore, any method calling doA() must either handle the exception (with try-catch) or declare that it also throws Exception. Currently, doB() calls doA() but does neither, causing a compile-time error. If doB() is fixed to throws Exception, then main() which calls doB() must also either handle or declare the exception. Thus, both doB() and main() need throws Exception in their signatures for the code to compile."
Working with Java API,String Class,What will the following code print? public class StringTest { public static String modifyString(String text) { text.concat("" World""); text.replace('o', 'X'); return text; } public static void main(String[] args) { String message = ""Hello""; System.out.println(modifyString(message)); } },Hello World,HellX WXrld,Hello,HellX,Compilation error,C,"String objects are immutable in Java. Methods like concat() and replace() do not modify the original String object; instead, they return a new String object with the modifications. In modifyString, the return values of text.concat("" World"") and text.replace('o', 'X') are not assigned back to text or any other variable. Therefore, text inside the method still refers to the original ""Hello"" string. The method returns ""Hello""."
Working with Java API,Date Time API,Which of the following is a valid way to create a LocalDateTime object?,java.time.LocalDate.parse(""2023-01-01"");,java.time.LocalDateTime.parse(""2023-01-01"");,java.time.LocalDateTime.of(2023, 1, 1, 10, 30);,java.time.LocalDateTime.of(2023, ""January"", 1, 10, 30);,new java.time.LocalDateTime();,C,"LocalDate.parse(""2023-01-01"") creates a LocalDate, not LocalDateTime. LocalDateTime.parse(""2023-01-01"") will throw a DateTimeParseException because LocalDateTime requires both date and time components in the parse string. LocalDateTime.of(2023, 1, 1, 10, 30) is a valid of() method signature, taking year, month (as int), day, hour, and minute. LocalDateTime.of(2023, ""January"", 1, 10, 30) is invalid because the month argument must be an int or Month enum, not a String. LocalDateTime does not have a public no-arg constructor."
Working with Java API,Collections,What will be the output of the following code? List<String> list = new ArrayList<>(); list.add(""apple""); list.add(""banana""); list.add(""apple""); System.out.println(list.remove(""apple"") + "" "" + list.size());,true 2,false 3,true 3,false 2,Compilation error,A,"The remove(Object o) method of ArrayList removes the first occurrence of the specified element and returns a boolean indicating if the element was found and removed. Initially, list is [""apple"", ""banana"", ""apple""]. list.remove(""apple"") removes the first ""apple"", returning true. The list becomes [""banana"", ""apple""]. The size of the list is now 2. So, the output is true 2."
Using Operators and Decision Constructs,Compound Assignment,What is the value of x after the following code executes? int x = 10; x += 5; x /= 3; x %= 2;,0,1,2,3,Compilation error,B,"Let's trace the value of x: 1. int x = 10; -> x is 10. 2. x += 5; (equivalent to x = x + 5;) -> x becomes 10 + 5 = 15. 3. x /= 3; (equivalent to x = x / 3;) -> x becomes 15 / 3 = 5 (integer division). 4. x %= 2; (equivalent to x = x % 2;) -> x becomes 5 % 2 = 1. The final value of x is 1."
Working With Java Data Types,Primitive Casting,What is the output of the following code? double d = 10.5; int i = (int) d; System.out.println(i);,10.5,10,11,Compilation error,Runtime error,B,"When a double is cast to an int, the decimal part is truncated (removed), not rounded. So, 10.5 becomes 10. The output is 10."
Java Basics,Platform Independence,Which statement is true about Java bytecode?,It can run on any platform.,It can run on any platform only if it was compiled for that platform.,It can run on any platform that has the Java Runtime Environment.,It can run on any platform that has a Java compiler.,It can run on any platform only if that platform has both the Java Runtime Environment and a Java compiler.,C,"Java source code is compiled into bytecode (.class files). This bytecode is platform-independent. To run Java bytecode, a Java Virtual Machine (JVM) is required, which is part of the Java Runtime Environment (JRE). The JVM interprets or compiles the bytecode into machine-specific instructions."
Working with Methods and Encapsulation,Pass-by-Value,What will the following program print? public class ChangeTest { private int myValue = 0; public void showOne(int myValue) { myValue = myValue; } public void showTwo(int myValue) { this.myValue = myValue; } public static void main(String[] args) { ChangeTest ct = new ChangeTest(); ct.showTwo(200); System.out.println(ct.myValue); ct.showOne(100); System.out.println(ct.myValue); } },0 followed by 100.,100 followed by 100.,0 followed by 200.,100 followed by 200.,200 followed by 200.,E,"In showTwo(int myValue), this.myValue = myValue; correctly assigns the parameter 200 to the instance variable myValue. So, the first print outputs 200. In showOne(int myValue), myValue = myValue; assigns the method parameter to itself due to variable shadowing (the parameter myValue hides the instance variable myValue). This line has no effect on the instance variable. Thus, ct.myValue remains 200. The second print also outputs 200."
Working With Java Data Types,Autoboxing/Unboxing,What is the output of the following code? Integer a = 10; Integer b = 10; Integer c = 200; Integer d = 200; System.out.println(a == b); System.out.println(c == d);,true true,true false,false true,false false,Compilation error,B,"For Integer values between -128 and 127 (inclusive), Java caches the objects. So, a and b will refer to the same cached Integer object, making a == b true. For values outside this range, new Integer objects are typically created, so c and d will refer to different objects, making c == d false. This is a common trick question related to Integer caching."
Working with Inheritance,Object Casting,What is the output of the following code? class A {} class B extends A {} public class Test { public static void main(String[] args) { A objA = new B(); B objB = (B) objA; System.out.println(""Cast successful""); } },Cast successful,Compilation error,Runtime error (ClassCastException),Runtime error (other),None of the above.,A,"The code will compile and run successfully. objA is declared as type A but refers to an object of type B. Since B is a subclass of A, an A reference can point to a B object. The cast (B) objA is a downcast. This is valid at runtime because the actual object that objA refers to is a B object. If objA referred to an A object (e.g., A objA = new A();), then (B) objA would throw a ClassCastException at runtime."
Working with Java API,Date Time API,What will be the output? import java.time.LocalDate; import java.time.Period; public class DateTest { public static void main(String[] args) { LocalDate date = LocalDate.of(2023, 3, 27); Period period = Period.ofDays(1); date = date.plus(period); System.out.println(date); } },2023-03-27,2023-03-28,2023-03-26,Compilation error,Runtime error,B,"LocalDate.of(2023, 3, 27) creates a date object for March 27, 2023. Period.ofDays(1) creates a period of one day. date.plus(period) adds this period to the date. Since LocalDate objects are immutable, plus() returns a new LocalDate object with the incremented date, which is then assigned back to date. So, the date becomes March 28, 2023. The output is 2023-03-28."
Working with Java API,StringBuilder Class,What is the output of the following code? StringBuilder sb = new StringBuilder(""Hello""); sb.append("" World"").insert(0, ""Java ""); System.out.println(sb);,Hello World Java,Java Hello World,Java Hello World,Java World Hello,Compilation error,B,"StringBuilder objects are mutable. 1. sb.append("" World""): sb becomes ""Hello World"". This method returns the StringBuilder itself. 2. .insert(0, ""Java ""): The insert() method is then called on the modified StringBuilder. It inserts ""Java "" at index 0. sb becomes ""Java Hello World"". The output is ""Java Hello World""."
Working with Methods and Encapsulation,Default Constructors,Given the class: class MyClass { int x; } Which statement is true about its constructor?,It has an implicit public no-argument constructor.,It has an implicit default constructor that initializes x to 0.,It requires an explicit constructor to be defined.,It will not compile without a constructor.,It has an implicit private no-argument constructor.,B,"If no constructor is explicitly defined in a class, Java automatically provides a default no-argument constructor. This default constructor is public if the class is public, and has the same access as the class otherwise. It calls the no-argument constructor of its superclass (implicitly Object() if no explicit superclass). It also initializes instance variables to their default values (e.g., int to 0). So, MyClass gets an implicit public no-argument constructor that initializes x to 0."
Working With Java Data Types,Object References,What is the output of the following code? Object obj1 = new Object(); Object obj2 = obj1; obj1 = null; System.out.println(obj2 == null);,true,false,null,Compilation error,Runtime error,B,"1. Object obj1 = new Object(); obj1 refers to a new Object instance. 2. Object obj2 = obj1; obj2 now also refers to the same Object instance as obj1. 3. obj1 = null; obj1 is reassigned to null, but obj2 still refers to the original Object instance. Therefore, System.out.println(obj2 == null) will print false because obj2 is not null."
